;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname |26|) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
; questions to consider when creating an algorithm
; - what is a trivially solvable problem
; - how are trivial problems solved
; - how does the algorithm generate new problems that are more easily solvable than the original one? Is there one new problem that we generate or are there several?
; - is the solution of the given problem the same as the solution of (one of the new problems)? or, do we need to combine the solutions to create a solution for the original
; problem? and, if so, do we need anything from the original problem data?

; EX 431
; answer above 4 questions for bundle
; - a trivially solvable problem for bundle is an empty list
; - an empty list is solved, for the purposes of bundle, by returning the input as is
; - new problems are generated by the drop function. each problem is solved by the take function. one to arbitrarily many problems are generated depending on the length of the
; list inputted
; - the solutions of the new problems are combined to create the solution for the original problem. nothing is needed from the original problem data to do that in bundle's case

; answer first 3 questions for quick-sort<
; - a trivially solvable problem for quick-sort is an empty list or a list with one member.
; - trivially solvable problems are solved by quick-sort by returning the input as is
; - quick-sort generates new problems by partitioning the given list into two lists, one with all numbers less than the first number in the given list, the other with all numbers
; greater than the first number in the given list. for every member of the original list, two new problems are generated

; EX 432
; reformulate food-create into a single definition using local then justify its design
; Posn -> Posn 
; creates a random posn using a pre-existing posn. if the new posn is the same as the existing posn, another random posn is generated.
; EX 436 termination only loops if both calls to random create x and y values that are identical to the input posn's, will terminate once a position different from the input
; is generated
(define MAX 100)
(check-satisfied (food-create (make-posn 1 1)) not=-1-1?)
(define (food-create p)
  (local ( 
          (define (food-check-create candidate)
            (if (equal? p candidate) (food-create p) candidate)))
    (food-check-create
       (make-posn (random MAX) (random MAX)))))
 
; Posn -> Boolean
; use for testing only 
(define (not=-1-1? p)
  (not (and (= (posn-x p) 1) (= (posn-y p) 1))))

; EX 433
; checked version of bundle that is guaranteed to terminate for all inputs. signals an error for cases where the original version loops
; [List-of 1String] N -> [List-of String]
; bundles chunks of s into strings of length n
; idea take n items and drop n at a time
(define (bundle s n)
  (cond
    [(empty? s) '()]
    [(zero? n) (error "Cannot bundle chunks of length 0")] ; ex 433 solution
    [else
     (cons (implode (take s n)) (bundle (drop s n) n))]))

    (check-expect (bundle (explode "abcdefg") 3)
                  (list "abc" "def" "g"))
 
; [List-of X] N -> [List-of X]
; keeps the first n items from l if possible or everything
(define (take l n)
  (cond
    [(zero? n) '()]
    [(empty? l) '()]
    [else (cons (first l) (take (rest l) (sub1 n)))]))
 
; [List-of X] N -> [List-of X]
; removes the first n items from l if possible or everything
(define (drop l n)
  (cond
    [(zero? n) l]
    [(empty? l) l]
    [else (drop (rest l) (sub1 n))]))

; EX 434
; a version of smallers will loop continuously if it checks each member of a given list against the pivot number with a less than or equal to sign because the pivot will be
; included in the output list resulting in an output that doesn't decrease in size after each recursive call of the function

; EX 435
; version of quick-sort< where smallers and largers receive lists that are shorter than the list given to quick-sort<
; solution is to make the list argument to smallers and largers, within quick-sort<, be (rest alon) instead of alon

; EX 436
; termination argument for food-create, see EX 432

; EX 437
; use the following template, which is analgous to a single-generative step algorithm template, to define 3 list-processing functions by defining solve and combine-solutions
; (define (special P)
;   (cond
;     [(empty? P) (solve P)]
;     [else
;      (combine-solutions
;        P
;        (special (rest P)))]))

; to compute the length of its input
(define (special-length P)
  (cond
    [(empty? P) (solve-length P)]
    [else
     (combine-solutions-length P (special-length (rest P)))]))

(define (solve-length p)
  (length p))
(define (combine-solutions-length orig-in recursion)
  (+ 1 recursion))
(check-expect (special-length (list 1 2 3 4 5 6)) 6)

; negate each number on the given list of numbers
(define (special-negate P)
  (cond
    [(empty? P) (solve-negate P)]
    [else
     (combine-solutions-negate P (special-negate (rest P)))]))

(define (solve-negate in)
  '())
(define (combine-solutions-negate in-list recursion)
  (cons (* -1 (first in-list)) recursion))
(check-expect (special-negate (list 1 2 3 4 5)) (list -1 -2 -3 -4 -5))

; uppercase the given list of strings
(define (special-upper P)
  (cond
    [(empty? P) (solve-upper P)]
    [else
     (combine-solutions-upper P (special-upper (rest P)))]))

(define (solve-upper p)
  '())
(define (combine-solutions-upper in-list recursion)
  (cons (string-upcase (first in-list)) recursion))
(check-expect (special-upper (list "how" "now" "brown")) (list "HOW" "NOW" "BROWN"))

; N[>= 1] N[>= 1] -> N
; finds the greatest common divisor of n and m
(define (gcd-structural n m)
  (local (; N -> N
          ; determines the gcd of n and m less than i
          (define (greatest-divisor-<= i)
            (cond
              [(= i 1) 1]
              [else
               (if (= (remainder n i) (remainder m i) 0)
                   i
                   (greatest-divisor-<= (- i 1)))])))
    (greatest-divisor-<= (min n m))))

; EX 438 - describe how the above function works and answer why the locally defined greatest-divisor-<= recur on (min n m):
; greatest-divisor-<= checks if the two numbers given to the top-level function return a remainder when divided by the number fed to greatest-divisor-<=,
; if neither return a remainder, the function returns the number it was given, if either of the numbers return a remainder, the function is recalled on the number it was
; initially given, minus 1. if the number given to greatest-divisor-< is 1, the function returns 1. greatest-divisor-<= is called on (min n m) because the greatest common divisor
; of n and m cannot be greater than the smaller of n and m and greatest-divisor-<= recurses on numbers that become progressively smaller as the function checks for a common
; divisor

; finds the gcd using the insight that the gcd of any two numbers is the gcd of the smaller number and the remainder of the larger number divided by the smaller number
(define (gcd-generative n m)
  (local (; N[>= 1] N[>=1] -> N
          ; generative recursion
          ; (gcd L S) == (gcd S (remainder L S)) 
          (define (clever-gcd L S)
            (cond
              [(= S 0) L]
              [else (clever-gcd S (remainder L S))])))
    (clever-gcd (max m n) (min m n))))

; EX 439 and 440: shows how long gcd-structural takes compared to gcd-generative using the time function
; EX 441: shows how a general rule cannot be applied to determine the number of recursions it will take to sort a list based
; on the number of members in a list because parts of the list may already be sorted

; EX 442
; determine the point where quick-sort< begins to complete sorting faster than sort< using the create-tests function
; result is ~83
(define (quick-sort< alon)
  (cond
    [(empty? alon) '()]
    [(equal? (length alon) 1) alon]
    [else (local ((define pivot (first alon)))
            (append (quick-sort< (smallers alon pivot))
                    (accum-dupes alon pivot)
                    (quick-sort< (largers alon pivot))))]))

(define (return-half opr alon pivot)
  (cond
    [(empty? alon) '()]
    [else (local ((define first-alon (first alon)))
            (if (opr first-alon pivot) (cons first-alon (return-half opr (rest alon) pivot))
              (return-half opr (rest alon) pivot)))]))

(define (smallers alon pivot)
  (return-half < alon pivot))

(define (largers alon pivot)
  (return-half > alon pivot))

(define (accum-dupes alon n)
  (cond
    [(empty? alon) '()]
    [else (local ((define first-alon (first alon)))
            (if (equal? first-alon n) (cons first-alon (accum-dupes (rest alon) n))
                (accum-dupes (rest alon) n)))]))

; List-of-numbers -> List-of-numbers
; produces a sorted version of l
(define (sort< l)
  (cond
    [(empty? l) '()]
    [(cons? l) (insert (first l) (sort< (rest l)))]))
 
; Number List-of-numbers -> List-of-numbers
; inserts n into the sorted list of numbers l 
(define (insert n l)
  (cond
    [(empty? l) (cons n '())]
    [else (if (<= n (first l))
              (cons n l)
              (cons (first l) (insert n (rest l))))]))

;(check-expec (quick-sort< (list 1 14 0 14 3 4 7 8 8 1 1 6 7 5 2 2 3 2 0 0))
;             (list
; creates large test cases of length len randomly for sort< and quick-sort<
(define (create-tests len)
  (local ((define (create-list local-len)
            (cond
              [(zero? len) '()]
              [else (cons (random len) (create-tests (- local-len 1)))])))
    (create-list len)))

(define (test-quick x)
  (time (quick-sort< (create-tests x))))
(define (test-reg-sort x)
  (time (sort< (create-tests x))))

; EX 443 - explain why it would be impossible to find a divisor using the following template
(define (wrong-gcd-structural n m)
  (cond
    [(and (= n 1) (= m 1)) ...]
    [(and (> n 1) (= m 1)) ...]
    [(and (= n 1) (> m 1)) ...]
    [else
     (... (gcd-structural (sub1 n) (sub1 m)) ...
      ... (gcd-structural (sub1 n) m) ...
      ... (gcd-structural n (sub1 m)) ...)]))
; it would be impossible to find a divisor using the template above because the base cases will return 1 and the recursions will all inevitably reach the base case

; EX 444 - explain why divisors, in the suite of functions below, consumes two numbers and consumes S as the first argument in both uses
; the first number divisor consumes limits the the size of the output list, this allows the top-level function to save cycles when it is processing both divisor lists with
; largest-common
(define (gcd-structural S L)
  (largest-common (divisors S S) (divisors S L)))
 
; N[>= 1] N[>= 1] -> [List-of N]
; computes the divisors of l smaller or equal to k
(define (divisors k l)
  '())
 
; [List-of N] [List-of N] -> N
; finds the largest number common to both k and l
(define (largest-common k l)
  1)