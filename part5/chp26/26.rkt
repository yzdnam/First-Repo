;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname |26|) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
; questions to consider when creating an algorithm
; - what is a trivially solvable problem
; - how are trivial problems solved
; - how does the algorithm generate new problems that are more easily solvable than the original one? Is there one new problem that we generate or are there several?
; - is the solution of the given problem the same as the solution of (one of the new problems)? or, do we need to combine the solutions to create a solution for the original
; problem? and, if so, do we need anything from the original problem data?

; EX 431
; answer above 4 questions for bundle
; - a trivially solvable problem for bundle is an empty list
; - an empty list is solved, for the purposes of bundle, by returning the input as is
; - new problems are generated by the drop function. each problem is solved by the take function. one to arbitrarily many problems are generated depending on the length of the
; list inputted
; - the solutions of the new problems are combined to create the solution for the original problem. nothing is needed from the original problem data to do that in bundle's case

; answer first 3 questions for quick-sort<
; - a trivially solvable problem for quick-sort is an empty list or a list with one member.
; - trivially solvable problems are solved by quick-sort by returning the input as is
; - quick-sort generates new problems by partitioning the given list into two lists, one with all numbers less than the first number in the given list, the other with all numbers
; greater than the first number in the given list. for every member of the original list, two new problems are generated

; EX 432
; reformulate food-create into a single definition using local then justify its design
; Posn -> Posn 
; creates a random posn using a pre-existing posn. if the new posn is the same as the existing posn, another random posn is generated.
; EX 436 termination only loops if both calls to random create x and y values that are identical to the input posn's, will terminate once a position different from the input
; is generated
(define MAX 100)
(check-satisfied (food-create (make-posn 1 1)) not=-1-1?)
(define (food-create p)
  (local ( 
          (define (food-check-create candidate)
            (if (equal? p candidate) (food-create p) candidate)))
    (food-check-create
       (make-posn (random MAX) (random MAX)))))
 
; Posn -> Boolean
; use for testing only 
(define (not=-1-1? p)
  (not (and (= (posn-x p) 1) (= (posn-y p) 1))))

; EX 433
; checked version of bundle that is guaranteed to terminate for all inputs. signals an error for cases where the original version loops
; [List-of 1String] N -> [List-of String]
; bundles chunks of s into strings of length n
; idea take n items and drop n at a time
(define (bundle s n)
  (cond
    [(empty? s) '()]
    [(zero? n) (error "Cannot bundle chunks of length 0")] ; ex 433 solution
    [else
     (cons (implode (take s n)) (bundle (drop s n) n))]))

    (check-expect (bundle (explode "abcdefg") 3)
                  (list "abc" "def" "g"))
 
; [List-of X] N -> [List-of X]
; keeps the first n items from l if possible or everything
(define (take l n)
  (cond
    [(zero? n) '()]
    [(empty? l) '()]
    [else (cons (first l) (take (rest l) (sub1 n)))]))
 
; [List-of X] N -> [List-of X]
; removes the first n items from l if possible or everything
(define (drop l n)
  (cond
    [(zero? n) l]
    [(empty? l) l]
    [else (drop (rest l) (sub1 n))]))

; EX 434
; a version of smallers will loop continuously if it checks each member of a given list against the pivot number with a less than or equal to sign because the pivot will be
; included in the output list resulting in an output that doesn't decrease in size after each recursive call of the function

; EX 435
; version of quick-sort< where smallers and largers receive lists that are shorter than the list given to quick-sort<
; solution is to make the list argument to smallers and largers, within quick-sort<, be (rest alon) instead of alon

; EX 436
; termination argument for food-create, see EX 432

; EX 437
; use the following template, which is analgous to a single-generative step algorithm template, to define 3 list-processing functions by defining solve and combine-solutions
; (define (special P)
;   (cond
;     [(empty? P) (solve P)]
;     [else
;      (combine-solutions
;        P
;        (special (rest P)))]))

; to compute the length of its input
(define (special-length P)
  (cond
    [(empty? P) (solve-length P)]
    [else
     (combine-solutions-length P (special-length (rest P)))]))

(define (solve-length p)
  (length p))
(define (combine-solutions-length orig-in recursion)
  (+ 1 recursion))
(check-expect (special-length (list 1 2 3 4 5 6)) 6)

; negate each number on the given list of numbers
(define (special-negate P)
  (cond
    [(empty? P) (solve-negate P)]
    [else
     (combine-solutions-negate P (special-negate (rest P)))]))

(define (solve-negate in)
  '())
(define (combine-solutions-negate in-list recursion)
  (cons (* -1 (first in-list)) recursion))
(check-expect (special-negate (list 1 2 3 4 5)) (list -1 -2 -3 -4 -5))

; uppercase the given list of strings
(define (special-upper P)
  (cond
    [(empty? P) (solve-upper P)]
    [else
     (combine-solutions-upper P (special-upper (rest P)))]))

(define (solve-upper p)
  '())
(define (combine-solutions-upper in-list recursion)
  (cons (string-upcase (first in-list)) recursion))
(check-expect (special-upper (list "how" "now" "brown")) (list "HOW" "NOW" "BROWN"))

; N[>= 1] N[>= 1] -> N
; finds the greatest common divisor of n and m
(define (gcd-structural n m)
  (local (; N -> N
          ; determines the gcd of n and m less than i
          (define (greatest-divisor-<= i)
            (cond
              [(= i 1) 1]
              [else
               (if (= (remainder n i) (remainder m i) 0)
                   i
                   (greatest-divisor-<= (- i 1)))])))
    (greatest-divisor-<= (min n m))))

; EX 438 - describe how the above function works and answer why the locally defined greatest-divisor-<= recur on (min n m):
; greatest-divisor-<= checks if the two numbers given to the top-level function return a remainder when divided by the number fed to greatest-divisor-<=,
; if neither return a remainder, the function returns the number it was given, if either of the numbers return a remainder, the function is recalled on the number it was
; initially given, minus 1. if the number given to greatest-divisor-< is 1, the function returns 1. greatest-divisor-<= is called on (min n m) because the greatest common divisor
; of n and m cannot be greater than the smaller of n and m and greatest-divisor-<= recurses on numbers that become progressively smaller as the function checks for a common
; divisor