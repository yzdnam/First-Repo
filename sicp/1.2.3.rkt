#lang sicp

; EX 1.14

(define (cc amount) (cc-steps amount (list 50 25 10 5 1) 1))
(define (cc-steps amount kinds-of-coins steps)
  (cond [(= amount 0) steps]
        [(or (< amount 0) (eqv? kinds-of-coins '())) steps]
        [else (+ steps
                 (cc-steps amount (cdr kinds-of-coins) 1)
                 (cc-steps (- amount (car kinds-of-coins)) kinds-of-coins 1))]))

; version of count-change to version that counts steps correctly
(define (csteps amount) (cc.v2 amount 5 1))
(define (cc.v2 amount kinds-of-coins steps) 
  (cond ((= amount 0) steps)
        ((or (< amount 0) (= kinds-of-coins 0)) steps)
        (else (+ steps
                 (cc.v2 amount
                        (- kinds-of-coins 1) 1)
                 (cc.v2 (- amount
                           (first-denomination
                            kinds-of-coins))
                        kinds-of-coins 1)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

; if a = amount to be changed
; and d = # of denominations of coins used
; for an amount, a, and d = 1, count-change will carry out a # of steps proprtional to a. For example, if only using pennies, count-change will carry out 2a+1 steps
; to reach a result.
; If using d = 2, count-change will carry out a number of steps proportional to a^2. For example, if using pennies and nickels, count-change will carry out approx.
; 2a+1 + (2a+1)(a/5) steps to reach a results. This simplifies down to (2a^2+a)/5 or θ(a^2). The same logic follows for any arbitrary number of different kinds of
; coins hence the order of growth of time for count-change is θ(a^d).
; the maximum depth of an application of count-change is a+5 hence the order of growth of space for count-change is θ(a).

; EX 1.15
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
           angle
           (p (sine (/ angle 3.0)))))

; p is applied 5 times
; p is applied once for each complete power of 3 contained within angle a. therefore, given a positive argument, we can compute the number of times p is applied as
; the ceiling of the base 3 logarithm of the argument divided by 0.1, or (ceiling(/ (log (/ 12.15 0.1)) (log 3))) for (sine 12.15). If measuring the required space
; and number of steps by counting the invocations of p, the order of growth of the process generated by (sine a) is logarithmic. Exactly, the number of steps required
; are (ceiling(/ (log (/ a 0.1)) (log 3))). which simplifies to θ(log(a)) order of growth.